{"version":3,"names":[],"sources":["types.ts"],"sourcesContent":["import type {\n  SendbirdChatSDK,\n  SendbirdError,\n  SendbirdFileMessage,\n  SendbirdFileMessageCreateParams,\n  SendbirdFileMessageUpdateParams,\n  SendbirdGroupChannel,\n  SendbirdGroupChannelCollection,\n  SendbirdGroupChannelListQuery,\n  SendbirdMessage,\n  SendbirdMessageCollection,\n  SendbirdOpenChannel,\n  SendbirdOpenChannelListQuery,\n  SendbirdPreviousMessageListQuery,\n  SendbirdUserMessage,\n  SendbirdUserMessageCreateParams,\n  SendbirdUserMessageUpdateParams,\n  UserStruct,\n} from '@sendbird/uikit-utils';\n\nexport interface CustomQueryInterface<Data> {\n  isLoading: boolean;\n  next: () => Promise<Data[]>;\n  hasNext: boolean;\n}\nexport interface CustomBidirectionalQueryInterface<Data> {\n  isLoading: boolean;\n  next: () => Promise<Data[]>;\n  hasNext: () => boolean;\n  prev: () => Promise<Data[]>;\n  hasPrev: () => boolean;\n}\n\n/**\n * @interface UseGroupChannelList\n * @description interface for group channel list hook\n * */\nexport interface UseGroupChannelList {\n  (sdk: SendbirdChatSDK, userId?: string, options?: UseGroupChannelListOptions): {\n    /**\n     * Loading state, only available on first render\n     * */\n    loading: boolean;\n\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing: boolean;\n\n    /**\n     * Refresh, clear and reload messages from latest\n     * @return {Promise<void>}\n     * */\n    refresh: () => Promise<void>;\n\n    /**\n     * Get group channels state\n     * */\n    groupChannels: SendbirdGroupChannel[];\n\n    /**\n     * Fetch next channels to state\n     * @return {Promise<void>}\n     * */\n    next: () => Promise<void>;\n  };\n}\nexport type UseGroupChannelListOptions = {\n  queryCreator?: () => SendbirdGroupChannelListQuery;\n  collectionCreator?: () => SendbirdGroupChannelCollection;\n  enableCollectionWithoutLocalCache?: boolean;\n};\n\n/**\n * @interface UseGroupChannelMessages\n * @description interface for group channel messages hook\n * - Receive new messages from other users & should count new messages -> append to state(newMessages)\n * - onTopReached -> prev() -> fetch prev messages and append to state(messages)\n * - onBottomReached -> next() -> fetch next messages and append to state(messages)\n * */\nexport interface UseGroupChannelMessages {\n  (sdk: SendbirdChatSDK, channel: SendbirdGroupChannel, userId?: string, options?: UseGroupChannelMessagesOptions): {\n    /**\n     * Loading state, only available on first render\n     * */\n    loading: boolean;\n\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing: boolean;\n\n    /**\n     * Refresh, clear and reload messages from latest\n     * @return {Promise<void>}\n     * */\n    refresh: () => Promise<void>;\n\n    /**\n     * Get messages, this state is for render\n     * For example, if a user receives a new messages while searching for an old message\n     * for this case, new messages will be included here.\n     * @return {SendbirdMessage[]}\n     * */\n    messages: SendbirdMessage[];\n\n    /**\n     * Fetch prev messages to state\n     * @return {Promise<void>}\n     * */\n    prev: () => Promise<void>;\n\n    /**\n     * Check if there are more prev messages to fetch\n     * @return {boolean}\n     * */\n    hasPrev: () => boolean;\n\n    /**\n     * Fetch next messages to state\n     * @return {Promise<void>}\n     * */\n    next: () => Promise<void>;\n\n    /**\n     * Check if there are more next messages to fetch\n     * @return {boolean}\n     * */\n    hasNext: () => boolean;\n\n    /**\n     * A new message means a message that meets the below conditions\n     * - Not admin message\n     * - Not updated message\n     * - Not current user's message\n     * */\n    newMessages: SendbirdMessage[];\n\n    /**\n     * reset message list with starting point\n     * */\n    resetWithStartingPoint: (startingPoint: number, callback?: () => void) => void;\n\n    /**\n     * Reset new messages\n     * */\n    resetNewMessages: () => void;\n\n    /**\n     * Send file message\n     * @param params file message params\n     * @param callback sent message callback\n     * @return pending message\n     * */\n    sendFileMessage: (\n      params: SendbirdFileMessageCreateParams,\n      onPending?: (message: SendbirdFileMessage, error?: SendbirdError) => void,\n    ) => Promise<SendbirdFileMessage>;\n\n    /**\n     * Send user message\n     * @param params user message params\n     * @param callback sent message callback\n     * @return pending message\n     * */\n    sendUserMessage: (\n      params: SendbirdUserMessageCreateParams,\n      onPending?: (message: SendbirdUserMessage, error?: SendbirdError) => void,\n    ) => Promise<SendbirdUserMessage>;\n\n    /**\n     * Update file message\n     * @param messageId\n     * @param params file message params\n     * @return updated message\n     * */\n    updateFileMessage: (messageId: number, params: SendbirdFileMessageUpdateParams) => Promise<SendbirdFileMessage>;\n\n    /**\n     * Update user message\n     * @param messageId\n     * @param params user message params\n     * @return updated message\n     * */\n    updateUserMessage: (messageId: number, params: SendbirdUserMessageUpdateParams) => Promise<SendbirdUserMessage>;\n\n    /**\n     * Resend failed message\n     * @param failedMessage failed message to resend\n     * @return {Promise<void>}\n     * */\n    resendMessage: (failedMessage: SendbirdFileMessage | SendbirdUserMessage) => Promise<void>;\n\n    /**\n     * Delete message\n     * @param message sent or failed message\n     * @return {Promise<void>}\n     * */\n    deleteMessage: (message: SendbirdFileMessage | SendbirdUserMessage) => Promise<void>;\n\n    /** @deprecated Please use `newMessages` instead **/\n    newMessagesFromMembers: SendbirdMessage[];\n    /** @deprecated Please use `newMessages` instead **/\n    nextMessages: SendbirdMessage[];\n  };\n}\n\nexport type UseGroupChannelMessagesOptions = {\n  sortComparator?: (a: SendbirdMessage, b: SendbirdMessage) => number;\n  queryCreator?: () => SendbirdPreviousMessageListQuery;\n  collectionCreator?: (options?: Pick<UseGroupChannelMessagesOptions, 'startingPoint'>) => SendbirdMessageCollection;\n  enableCollectionWithoutLocalCache?: boolean;\n  onChannelDeleted?: () => void;\n  shouldCountNewMessages?: () => boolean;\n  startingPoint?: number;\n  onMessagesReceived?: (messages: SendbirdMessage[]) => void;\n};\n\n/**\n * @interface UseOpenChannelList\n * @description interface for open channel list hook\n * */\nexport interface UseOpenChannelList {\n  (sdk: SendbirdChatSDK, userId?: string, options?: UseOpenChannelListOptions): {\n    /**\n     * Loading state, only available on first render\n     * */\n    loading: boolean;\n\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing: boolean;\n\n    /**\n     * Refresh, clear and reload messages from latest\n     * @return {Promise<void>}\n     * */\n    refresh: () => Promise<void>;\n\n    /**\n     * Error state\n     * */\n    error: unknown | null;\n\n    /**\n     * Get open channels state\n     * */\n    openChannels: SendbirdOpenChannel[];\n\n    /**\n     * Fetch next channels to state\n     * @return {Promise<void>}\n     * */\n    next: () => Promise<void>;\n  };\n}\nexport type UseOpenChannelListOptions = {\n  queryCreator?: () => SendbirdOpenChannelListQuery;\n};\n\n/**\n * @interface UseOpenChannelMessages\n * @description interface for open channel messages hook\n * - Receive new messages from other users & should count new messages -> append to state(newMessages)\n * - onTopReached -> prev() -> fetch prev messages and append to state(messages)\n * - onBottomReached -> noop\n * */\nexport interface UseOpenChannelMessages {\n  (sdk: SendbirdChatSDK, channel: SendbirdOpenChannel, userId?: string, options?: UseOpenChannelMessagesOptions): {\n    /**\n     * Loading state, only available on first render\n     * */\n    loading: boolean;\n\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing: boolean;\n\n    /**\n     * Refresh, clear and reload messages from latest\n     * @return {Promise<void>}\n     * */\n    refresh: () => Promise<void>;\n\n    /**\n     * Get messages, this state is for render\n     * For example, if a user receives a new messages while searching for an old message\n     * for this case, new messages will be included here.\n     * @return {SendbirdMessage[]}\n     * */\n    messages: SendbirdMessage[];\n\n    /**\n     * Fetch prev messages to state\n     * @return {Promise<void>}\n     * */\n    prev: () => Promise<void>;\n\n    /**\n     * Check if there are more prev messages to fetch\n     * @return {boolean}\n     * */\n    hasPrev: () => boolean;\n\n    /**\n     * A new message means a message that meets the below conditions\n     * - Not admin message\n     * - Not updated message\n     * - Not current user's message\n     * */\n    newMessages: SendbirdMessage[];\n\n    /**\n     * Reset new messages\n     * */\n    resetNewMessages: () => void;\n\n    /**\n     * Fetch next messages to state\n     * @return {Promise<void>}\n     * */\n    next: () => Promise<void>;\n\n    /**\n     * Check if there are more next messages to fetch\n     * @return {boolean}\n     * */\n    hasNext: () => boolean;\n\n    /**\n     * Send file message\n     * @param params file message params\n     * @param callback sent message callback\n     * @return pending message\n     * */\n    sendFileMessage: (\n      params: SendbirdFileMessageCreateParams,\n      onPending?: (message: SendbirdFileMessage, error?: SendbirdError) => void,\n    ) => Promise<SendbirdFileMessage>;\n\n    /**\n     * Send user message\n     * @param params user message params\n     * @param callback sent message callback\n     * @return pending message\n     * */\n    sendUserMessage: (\n      params: SendbirdUserMessageCreateParams,\n      onPending?: (message: SendbirdUserMessage, error?: SendbirdError) => void,\n    ) => Promise<SendbirdUserMessage>;\n\n    /**\n     * Update file message\n     * @param messageId\n     * @param params file message params\n     * @return updated message\n     * */\n    updateFileMessage: (messageId: number, params: SendbirdFileMessageUpdateParams) => Promise<SendbirdFileMessage>;\n\n    /**\n     * Update user message\n     * @param messageId\n     * @param params user message params\n     * @return updated message\n     * */\n    updateUserMessage: (messageId: number, params: SendbirdUserMessageUpdateParams) => Promise<SendbirdUserMessage>;\n\n    /**\n     * Resend failed message\n     * @param failedMessage failed message to resend\n     * @return {Promise<void>}\n     * */\n    resendMessage: (failedMessage: SendbirdFileMessage | SendbirdUserMessage) => Promise<void>;\n\n    /**\n     * Delete message\n     * @param message sent or failed message\n     * @return {Promise<void>}\n     * */\n    deleteMessage: (message: SendbirdFileMessage | SendbirdUserMessage) => Promise<void>;\n\n    /** @deprecated Please use `newMessages` instead **/\n    newMessagesFromMembers: SendbirdMessage[];\n    /** @deprecated Please use `newMessages` instead **/\n    nextMessages: SendbirdMessage[];\n  };\n}\n\nexport type UseOpenChannelMessagesOptions = {\n  sortComparator?: (a: SendbirdMessage, b: SendbirdMessage) => number;\n  queryCreator?: () => SendbirdPreviousMessageListQuery;\n  onChannelDeleted?: () => void;\n  onError?: (error?: unknown) => void;\n  shouldCountNewMessages?: () => boolean;\n  onMessagesReceived?: (messages: SendbirdMessage[]) => void;\n};\n\n/**\n * @interface UseUserListReturn\n * @description interface for user list hook return value\n * */\nexport interface UseUserListReturn<User extends UserStruct> {\n  /**\n   * Loading state, only available on first render\n   * */\n  loading: boolean;\n\n  /**\n   * Refreshing state, status is changes when the refresh is called.\n   * */\n  refreshing: boolean;\n\n  /**\n   * Error state\n   * */\n  error: unknown | null;\n\n  /**\n   * Refresh, clear and reload messages from latest\n   * @return {Promise<void>}\n   * */\n  refresh: () => Promise<void>;\n\n  /**\n   * Get users state\n   * */\n  users: User[];\n\n  /**\n   * Update or Insert user to list\n   * */\n  upsertUser: (user: User) => void;\n\n  /**\n   * Delete user from list\n   * */\n  deleteUser: (userId: User['userId']) => void;\n\n  /**\n   * Fetch next users to state\n   * @return {Promise<void>}\n   * */\n  next: () => Promise<void>;\n}\n\nexport type UseUserListOptions<User extends UserStruct> = {\n  sortComparator?: (a: User, b: User) => number;\n  queryCreator?: () => CustomQueryInterface<User>;\n};\n"],"mappings":""}